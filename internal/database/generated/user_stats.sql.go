// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_stats.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getUserRankingById = `-- name: GetUserRankingById :many
SELECT 
    u.username,
    us.total_accepted,
    us.total_submissions,
    CASE 
        WHEN us.total_submissions > 0 
        THEN ROUND((us.total_accepted::NUMERIC / us.total_submissions::NUMERIC) * 100, 2)
        ELSE 0 
    END as acceptance_rate
FROM user_stats us
JOIN users u ON u.id = us.user_id
ORDER BY us.total_accepted DESC, acceptance_rate DESC
LIMIT $1
`

type GetUserRankingByIdRow struct {
	Username         string `db:"username" json:"username"`
	TotalAccepted    int32  `db:"total_accepted" json:"total_accepted"`
	TotalSubmissions int32  `db:"total_submissions" json:"total_submissions"`
	AcceptanceRate   int32  `db:"acceptance_rate" json:"acceptance_rate"`
}

func (q *Queries) GetUserRankingById(ctx context.Context, limit int32) ([]GetUserRankingByIdRow, error) {
	rows, err := q.db.Query(ctx, getUserRankingById, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserRankingByIdRow
	for rows.Next() {
		var i GetUserRankingByIdRow
		if err := rows.Scan(
			&i.Username,
			&i.TotalAccepted,
			&i.TotalSubmissions,
			&i.AcceptanceRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStatsById = `-- name: GetUserStatsById :one
SELECT 
    total_submissions,
    total_accepted,
    CASE 
        WHEN total_submissions > 0 
        THEN ROUND((total_accepted::NUMERIC / total_submissions::NUMERIC) * 100, 2)
        ELSE 0 
    END as acceptance_rate
FROM user_stats 
WHERE user_id = $1
`

type GetUserStatsByIdRow struct {
	TotalSubmissions int32 `db:"total_submissions" json:"total_submissions"`
	TotalAccepted    int32 `db:"total_accepted" json:"total_accepted"`
	AcceptanceRate   int32 `db:"acceptance_rate" json:"acceptance_rate"`
}

func (q *Queries) GetUserStatsById(ctx context.Context, userID int32) (GetUserStatsByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserStatsById, userID)
	var i GetUserStatsByIdRow
	err := row.Scan(&i.TotalSubmissions, &i.TotalAccepted, &i.AcceptanceRate)
	return i, err
}

const userHasSolvedProblem = `-- name: UserHasSolvedProblem :one
SELECT EXISTS (
    SELECT 1 FROM submissions 
    WHERE user_id = $1
    AND problem_id = $2 
    AND status = 'OK'
)
`

type UserHasSolvedProblemParams struct {
	UserID    pgtype.Int4 `db:"user_id" json:"user_id"`
	ProblemID pgtype.Int4 `db:"problem_id" json:"problem_id"`
}

func (q *Queries) UserHasSolvedProblem(ctx context.Context, arg UserHasSolvedProblemParams) (bool, error) {
	row := q.db.QueryRow(ctx, userHasSolvedProblem, arg.UserID, arg.ProblemID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
