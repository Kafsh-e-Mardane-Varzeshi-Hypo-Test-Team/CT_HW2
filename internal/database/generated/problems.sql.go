// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: problems.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProblem = `-- name: CreateProblem :one
INSERT INTO problems (
  title, statement, time_limit_ms, memory_limit_mb, 
  sample_input, sample_output, owner_id, status
) VALUES (
  $1, $2, $3, $4, 
  $5, $6, $7, $8::problem_status
)
RETURNING id, title, statement, time_limit_ms, memory_limit_mb, sample_input, sample_output, owner_id, status, created_at, modified_at
`

type CreateProblemParams struct {
	Title         string        `db:"title" json:"title"`
	Statement     string        `db:"statement" json:"statement"`
	TimeLimitMs   int32         `db:"time_limit_ms" json:"time_limit_ms"`
	MemoryLimitMb int32         `db:"memory_limit_mb" json:"memory_limit_mb"`
	SampleInput   pgtype.Text   `db:"sample_input" json:"sample_input"`
	SampleOutput  pgtype.Text   `db:"sample_output" json:"sample_output"`
	OwnerID       int32         `db:"owner_id" json:"owner_id"`
	Status        ProblemStatus `db:"status" json:"status"`
}

func (q *Queries) CreateProblem(ctx context.Context, arg CreateProblemParams) (Problem, error) {
	row := q.db.QueryRow(ctx, createProblem,
		arg.Title,
		arg.Statement,
		arg.TimeLimitMs,
		arg.MemoryLimitMb,
		arg.SampleInput,
		arg.SampleOutput,
		arg.OwnerID,
		arg.Status,
	)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Statement,
		&i.TimeLimitMs,
		&i.MemoryLimitMb,
		&i.SampleInput,
		&i.SampleOutput,
		&i.OwnerID,
		&i.Status,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const deleteProblem = `-- name: DeleteProblem :exec
DELETE FROM problems
WHERE id = $1
`

func (q *Queries) DeleteProblem(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProblem, id)
	return err
}

const getProblemById = `-- name: GetProblemById :one
SELECT id, title, statement, time_limit_ms, memory_limit_mb, sample_input, sample_output, owner_id, status, created_at, modified_at FROM problems
WHERE id = $1
`

func (q *Queries) GetProblemById(ctx context.Context, id int32) (Problem, error) {
	row := q.db.QueryRow(ctx, getProblemById, id)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Statement,
		&i.TimeLimitMs,
		&i.MemoryLimitMb,
		&i.SampleInput,
		&i.SampleOutput,
		&i.OwnerID,
		&i.Status,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const listPublishedProblems = `-- name: ListPublishedProblems :many
SELECT id, title, statement, time_limit_ms, memory_limit_mb, sample_input, sample_output, owner_id, status, created_at, modified_at FROM problems
WHERE status = 'published'
ORDER BY id
`

func (q *Queries) ListPublishedProblems(ctx context.Context) ([]Problem, error) {
	rows, err := q.db.Query(ctx, listPublishedProblems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Problem
	for rows.Next() {
		var i Problem
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Statement,
			&i.TimeLimitMs,
			&i.MemoryLimitMb,
			&i.SampleInput,
			&i.SampleOutput,
			&i.OwnerID,
			&i.Status,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserProblems = `-- name: ListUserProblems :many
SELECT id, title, statement, time_limit_ms, memory_limit_mb, sample_input, sample_output, owner_id, status, created_at, modified_at FROM problems
WHERE owner_id = $1
ORDER BY id
`

func (q *Queries) ListUserProblems(ctx context.Context, ownerID int32) ([]Problem, error) {
	rows, err := q.db.Query(ctx, listUserProblems, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Problem
	for rows.Next() {
		var i Problem
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Statement,
			&i.TimeLimitMs,
			&i.MemoryLimitMb,
			&i.SampleInput,
			&i.SampleOutput,
			&i.OwnerID,
			&i.Status,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProblem = `-- name: UpdateProblem :one
UPDATE problems
SET title = $1, 
    statement = $2, 
    time_limit_ms = $3, 
    memory_limit_mb = $4, 
    sample_input = $5, 
    sample_output = $6, 
    status = $7::problem_status
WHERE id = $8
RETURNING id, title, statement, time_limit_ms, memory_limit_mb, sample_input, sample_output, owner_id, status, created_at, modified_at
`

type UpdateProblemParams struct {
	Title         string        `db:"title" json:"title"`
	Statement     string        `db:"statement" json:"statement"`
	TimeLimitMs   int32         `db:"time_limit_ms" json:"time_limit_ms"`
	MemoryLimitMb int32         `db:"memory_limit_mb" json:"memory_limit_mb"`
	SampleInput   pgtype.Text   `db:"sample_input" json:"sample_input"`
	SampleOutput  pgtype.Text   `db:"sample_output" json:"sample_output"`
	Status        ProblemStatus `db:"status" json:"status"`
	ID            int32         `db:"id" json:"id"`
}

func (q *Queries) UpdateProblem(ctx context.Context, arg UpdateProblemParams) (Problem, error) {
	row := q.db.QueryRow(ctx, updateProblem,
		arg.Title,
		arg.Statement,
		arg.TimeLimitMs,
		arg.MemoryLimitMb,
		arg.SampleInput,
		arg.SampleOutput,
		arg.Status,
		arg.ID,
	)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Statement,
		&i.TimeLimitMs,
		&i.MemoryLimitMb,
		&i.SampleInput,
		&i.SampleOutput,
		&i.OwnerID,
		&i.Status,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}
